

// Pukall LFSR 64 + LCG 64 - 1990
// 6502 Assembler source code
// CODE FREE TO USE EVEN FOR COMMERCIAL APPLICATIONS
// NO RESTRICTION

// First a 8-bytes seed must be put at seed:
// The seed can vary from 0 to $FFFFFFFFFFFFFFFF.

// And a 8-bytes seed must be put at seedlfsr:
// The seed can vary from 1 to $FFFFFFFFFFFFFFFF but never 0 otherwise the LFSR produces only bits to 0.

// Each call to the begin: function returns a pseudorandom byte in rndbyte:

// First init: must be call one time.
// After begin: must be call for each generated byte (rndbyte:) that can be use directly.

// The test vector is :

// For a seed lfsr = $FFFFFFFFFFFFFFFF
// and seed = $FFFFFFFFFFFFFFFF

// the first 50 bytes are :


// 83 CA C9 DF F3 82 B1 EB 1D 2D A2 6A 08 A4 7C 58 99 EB 8A 4F
// 99 B0 43 01 66 66 49 EC 77 C2 6E 91 6E E0 28 58 DD EF 5D 9D
// BE F4 DF 57 1D 27 CA B4 2B 16 

//----------------------------------------------------
// 			Main Program
//----------------------------------------------------

            
init:
    jsr initlfsr
    jsr initlcg
rts

begin:
    jsr startlfsr
    jsr beginlcg
    lda rndbytelfsr
    clc
    adc rndbyte
    sta rndbyte
    rts

initlfsr:   
    ldx #0
    
looplfsr:   
    jsr startlfsr
   inx
   cpx #64
   bne looplfsr
   rts
   
startlfsr:
        lda #$00
        sta rndbytelfsr
        lda #$01
        sta mask
   
beginlfsr:
        asl seedlfsr
        rol seedlfsr+1
        rol seedlfsr+2
        rol seedlfsr+3
        rol seedlfsr+4
        rol seedlfsr+5
        rol seedlfsr+6
        rol seedlfsr+7
        bcc notlfsr
        lda seedlfsr
        eor #$f1
        sta seedlfsr
        lda seedlfsr+1
        eor #$c4
        sta seedlfsr+1
        lda seedlfsr+2
        eor #$fa
        sta seedlfsr+2
        lda seedlfsr+3
        eor #$3a
        sta seedlfsr+3
        lda seedlfsr+4
        eor #$1e
        sta seedlfsr+4
        lda seedlfsr+5
        eor #$db
        sta seedlfsr+5
        lda seedlfsr+6
        eor #$87
        sta seedlfsr+6
        lda seedlfsr+7
        eor #$72
        sta seedlfsr+7

   lda rndbytelfsr
        ora mask
        sta rndbytelfsr
notlfsr:
   asl mask
        bcc beginlfsr
        rts

initlcg:
    lda     #6
    sta     pos
    rts
beginlcg:
    ldx     pos
    cpx     #6
    bne     rnd
    jsr     start
    ldx     #0
    clc
    php
loop0:
    lda     seed,x
    plp
    adc     dda,x
    php
    sta     seed,x
    inx
    cpx     #8
    bne     loop0
    plp
rnd:
    ldx     pos
    lda     seed,x
    sta     rndbyte
    dex
    cpx     #2
    bne     end2
end:
    lda     #6
    sta     pos
    rts
end2:
    stx     pos
    rts
start:
    lda     #0
    ldx     #15
loop:
    sta     result,x
    dex
    cpx    #7
    bne     loop
    ldy     #64       
part1:
    sty     storey
    ldx     #7
    lsr     seed,x
    php
    dex
loop1:
    plp
    ror     seed,x
    php
    dex
    cpx     #0
    bne     loop1
    plp
    ror     seed
    bcc     part2
    ldx     #7
    ldy     #0
    clc
    php
loop2:
    inx
    lda     result,x
    plp
    adc     two,y   
    php
    sta     result,x
    iny
    cpy     #8
    bne     loop2
    plp
part2:
    ror     
    php
    ldx     #15         
    sta     result,x
loop3:
    dex
    plp
    ror     result,x
    php
    cpx     #0
    bne     loop3
    plp
    ldy     storey
    dey             
    bne     jump
    ldx     #0
loop4:
    lda     result,x
    sta     seed,x
    inx
    cpx    #8
    bne     loop4
    rts
jump:
    jmp part1

seed: .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
rndbyte: .byte $FF
result: .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
two: .byte $2D,$7F,$95,$4C,$2D,$F4,$51,$58
dda: .byte $01,$00,$00,$00,$00,$00,$00,$00
storey: .byte $FF
pos: .byte $FF
seedlfsr: .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
mask:  .byte $00
rndbytelfsr: .byte $00


